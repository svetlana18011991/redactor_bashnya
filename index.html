<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Башня знаний</title>
  <style>
    :root{
      --hud-bg: rgba(10, 12, 18, .55);
      --panel-bg: rgba(20, 22, 30, .78);
      --panel-stroke: rgba(255,255,255,.12);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.72);
      --good: rgba(120, 255, 170, .95);
      --bad: rgba(255, 120, 140, .95);
      --shadow: 0 18px 60px rgba(0,0,0,.35);
    }
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:var(--text);overflow:hidden;background:#000;}
    #wrap{position:relative;width:100%;height:100%;}
    canvas{width:100%;height:100%;display:block;}

    /* ТАЙМЕР */
    #timerWrap { position: absolute; top: 0; left: 0; width: 100%; height: 8px; background: rgba(255,255,255,0.1); z-index: 20; display: none; }
    #timerBar { height: 100%; width: 100%; background: linear-gradient(90deg, #ff9a9e 0%, #ff5252 100%); transition: width 1s linear; }

    #hud{ position:absolute; left:12px; right:12px; top:12px; display:flex; gap:12px; align-items:center; pointer-events:none; z-index: 3; }
    .pill{ background:var(--hud-bg); border:1px solid rgba(255,255,255,.10); border-radius:999px; padding:10px 14px; box-shadow:var(--shadow); backdrop-filter: blur(10px); display:flex; gap:10px; align-items:center; white-space:nowrap; }
    #progressWrap{ flex:1; background:var(--hud-bg); border:1px solid rgba(255,255,255,.10); border-radius:999px; padding:10px 14px; box-shadow:var(--shadow); backdrop-filter: blur(10px); display:flex; align-items:center; gap:10px; min-width:160px; pointer-events:none; }
    #bar{ height:10px; flex:1; background:rgba(255,255,255,.12); border-radius:999px; overflow:hidden; border:1px solid rgba(255,255,255,.10); }
    #bar>div{ height:100%; width:0%; background: linear-gradient(90deg, rgba(120,190,255,.9), rgba(120,255,170,.85)); border-radius:999px; }
    #scorePill{ margin-left:auto; }
    #scoreNum{ font-weight:900; letter-spacing:.2px; }

    #nextBtn{ position:absolute; left:50%; bottom:88px; transform: translateX(160px); pointer-events:auto; border-radius:16px; padding:12px 14px; border:1px solid rgba(120,190,255,.35); background: rgba(120,190,255,.22); color: var(--text); font-weight: 900; cursor:pointer; box-shadow: var(--shadow); backdrop-filter: blur(10px); transition: transform .08s ease, filter .12s ease, opacity .12s ease; user-select:none; z-index: 4; }
    #nextBtn:active{ transform: translateX(160px) scale(.99); }
    #nextBtn[disabled]{ opacity:.45; cursor:not-allowed; filter:saturate(.7); }

    #overlay{ position:absolute; inset:0; display:none; align-items:center; justify-content:center; background: rgba(0,0,0,.25); backdrop-filter: blur(6px); z-index: 5; }
    #card{ width:min(640px, calc(100% - 24px)); background:var(--panel-bg); border:1px solid var(--panel-stroke); border-radius:18px; box-shadow:var(--shadow); padding:18px 18px 14px; }
    #cardHeader{ display:flex; align-items:flex-start; justify-content:space-between; gap:12px; margin-bottom:12px; }
    #title{ font-size:16px; color:var(--muted); letter-spacing:.2px; }
    #q{ font-size:20px; line-height:1.25; margin-top:6px; }
    #badge{ border-radius:999px; padding:6px 10px; border:1px solid rgba(255,255,255,.12); color:var(--muted); font-size:12px; white-space:nowrap; }
    #answers{ display:flex; flex-direction:column; gap:10px; margin-top:14px; }
    .btn{ width:100%; text-align:left; background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.12); border-radius:14px; padding:12px 12px; color:var(--text); cursor:pointer; transition: transform .08s ease, background .12s ease; }
    .btn:hover{ background:rgba(255,255,255,.11); }
    .btn:active{ transform:scale(.99); }

    #msg{ margin-top:12px; min-height:18px; font-size:14px; color:var(--muted); }
    #hint{ margin-top:10px; font-size:12px; color:rgba(255,255,255,.55); }

    #start{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background: radial-gradient(1200px 800px at 50% 45%, rgba(0,0,0,.15), rgba(0,0,0,.55)); backdrop-filter: blur(3px); z-index: 6; }
    #startCard{ width:min(700px, calc(100% - 24px)); background: rgba(20, 22, 30, .75); border: 1px solid rgba(255,255,255,.12); border-radius: 18px; box-shadow: var(--shadow); padding: 18px; }
    #startCard h1{ margin:0 0 8px 0; font-size:24px; }
    #startCard p{ margin:0 0 14px 0; color: var(--muted); line-height:1.35; }
    #play{ display:inline-flex; gap:10px; align-items:center; padding:12px 14px; border-radius:14px; border:1px solid rgba(120,190,255,.35); background: rgba(120,190,255,.22); color: var(--text); font-weight:900; cursor:pointer; }
    #play:hover{ background: rgba(120,190,255,.28); }

    #err{ display:none; margin-top:12px; padding:12px; border-radius:14px; border:1px solid rgba(255,120,140,.35); background: rgba(255,120,140,.12); color: rgba(255,235,238,.95); font-size:13px; line-height:1.35; }
    #err ul{ margin:8px 0 0 18px; }
    
    #finish{ position:absolute; inset:0; display:none; align-items:center; justify-content:center; background: rgba(0,0,0,.35); backdrop-filter: blur(8px); z-index: 7; }
    #finishCard{ width:min(680px, calc(100% - 24px)); border-radius:20px; border:1px solid rgba(255,255,255,.14); background: rgba(18, 20, 28, .75); box-shadow: var(--shadow); padding: 18px 18px 16px; text-align:center; }
    #finishTitle{ font-size:30px; font-weight:1000; letter-spacing:.3px; margin: 4px 0 8px; background: linear-gradient(90deg, rgba(120,190,255,.95), rgba(120,255,170,.95)); -webkit-background-clip:text; background-clip:text; color:transparent; }
    #finishText{ color: rgba(255,255,255,.82); font-size:18px; margin: 0 0 14px; }
    #restart{ display:inline-flex; gap:10px; align-items:center; padding:12px 14px; border-radius:14px; border:1px solid rgba(120,190,255,.35); background: rgba(120,190,255,.22); color: var(--text); font-weight:900; cursor:pointer; }
    #restart:hover{ background: rgba(120,190,255,.28); }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>
  <div id="timerWrap"><div id="timerBar"></div></div>
  <div id="hud">
    <div class="pill">Башня: <b id="heightTxt">0</b> блок(ов)</div>
    <div id="progressWrap">Прогресс <div id="bar"><div></div></div><span id="pct">0%</span></div>
    <div class="pill" id="scorePill">Счёт: <b id="scoreNum">0</b></div>
  </div>
  <button id="nextBtn" disabled>Далее →</button>
  <div id="overlay" role="dialog" aria-modal="true">
    <div id="card">
      <div id="cardHeader"><div><div id="title">Вопрос</div><div id="q">...</div></div><div id="badge">1 / 9</div></div>
      <div id="answers"></div>
      <div id="msg"></div>
      <div id="hint">Верно → блок опускается. Неверно (или время вышло) → блок взрывается.</div>
    </div>
  </div>
  <div id="start">
    <div id="startCard">
      <h1>Башня знаний</h1>
      <p>Первый блок падает сам. Дальше — нажимай <b>Далее</b>.<br/><b>Внимание:</b> Следи за таймером!</p>
      <button id="play">▶ Начать</button>
      <div id="err"><b>Ошибка файлов.</b><ul id="errList"></ul></div>
    </div>
  </div>
  <div id="finish">
    <div id="finishCard">
      <div id="finishTitle">Игра окончена!</div>
      <div id="finishText">Твой результат: <b id="finishScore">0</b></div>
      <button id="restart">↻ Сыграть ещё раз</button>
    </div>
  </div>
</div>

<script>
// --- ИНТЕГРАЦИЯ: Настройки ---
const REPO_URL = "https://svetlana18011991.github.io/redactor_bashnya/"; // Укажи свой репо
const BG_FILE = "1.png";
const BLOCK_FILES = ["3.png","4.png","5.png","6.png","7.png","8.png","9.png","10.png","11.png"];

// Вопросы по умолчанию
let QUESTIONS = [{ type:"choice", q:"Сколько будет 2 + 2?", options:["3","4","5"], answer:"4" }];
let TIMER_ENABLED = false;
let TIMER_SEC = 15;

// Чтение данных из редактора
try {
    const params = new URLSearchParams(window.location.search);
    const data = params.get('data');
    if(data) {
        const json = decodeURIComponent(escape(atob(data)));
        const config = JSON.parse(json);
        if(config.qs && config.qs.length > 0) QUESTIONS = config.qs;
        if(config.timer) { TIMER_ENABLED = true; TIMER_SEC = config.sec || 15; }
    }
} catch(e) { console.log("Нет данных редактора"); }

const SCORE_PER_BLOCK = 100;
const FALL_SPEED = 620;
const DROP_SPEED = 900;
const SHAKE_ON_BOOM = 18;
const SHAKE_ON_LAND = 7;
const SAFE_TOP_MARGIN = 86;
const SAFE_BOTTOM_MARGIN = 100;
const DESIRED_TOWER_WIDTH = () => Math.min(window.innerWidth * 0.38, 360);
const TRIM_ALPHA_MIN = 34;
const PROFILE_ALPHA_MIN = 22;
const CENTROID_ALPHA_MIN = 24;

const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
const overlay = document.getElementById("overlay");
const qEl = document.getElementById("q");
const badgeEl = document.getElementById("badge");
const answersEl = document.getElementById("answers");
const msgEl = document.getElementById("msg");
const startLayer = document.getElementById("start");
const playBtn = document.getElementById("play");
const finishLayer = document.getElementById("finish");
const finishScoreEl = document.getElementById("finishScore");
const restartBtn = document.getElementById("restart");
const errBox = document.getElementById("err");
const errList = document.getElementById("errList");
const heightTxt = document.getElementById("heightTxt");
const pctTxt = document.getElementById("pct");
const barFill = document.querySelector("#bar > div");
const scoreNum = document.getElementById("scoreNum");
const nextBtn = document.getElementById("nextBtn");
const timerWrap = document.getElementById("timerWrap");
const timerBar = document.getElementById("timerBar");

let W=0,H=0,DPR=1;
function resize(){
  DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  W = Math.floor(window.innerWidth); H = Math.floor(window.innerHeight);
  canvas.width = W * DPR; canvas.height = H * DPR; ctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener("resize", resize); resize();

let audioCtx=null;
function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
function playBoom(){
  ensureAudio(); const t = audioCtx.currentTime;
  const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
  osc.type="sawtooth"; osc.frequency.setValueAtTime(120,t); osc.frequency.exponentialRampToValueAtTime(38,t+0.22);
  gain.gain.setValueAtTime(0.0001,t); gain.gain.exponentialRampToValueAtTime(0.50,t+0.02); gain.gain.exponentialRampToValueAtTime(0.0001,t+0.34);
  osc.connect(gain).connect(audioCtx.destination); osc.start(t); osc.stop(t+0.36);
}
function playGood(){
  ensureAudio(); const t = audioCtx.currentTime;
  const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
  osc.type="triangle"; osc.frequency.setValueAtTime(420,t); osc.frequency.exponentialRampToValueAtTime(780,t+0.12);
  gain.gain.setValueAtTime(0.0001,t); gain.gain.exponentialRampToValueAtTime(0.20,t+0.02); gain.gain.exponentialRampToValueAtTime(0.0001,t+0.18);
  osc.connect(gain).connect(audioCtx.destination); osc.start(t); osc.stop(t+0.2);
}

// Загрузка картинок с учетом REPO_URL
function assetUrl(file){ if(file.startsWith("http")) return file; return REPO_URL + file; }
function loadImage(url){
  return new Promise((resolve, reject)=>{
    const img=new Image(); img.crossOrigin = "Anonymous";
    img.onload=()=>resolve(img); img.onerror=()=>reject(new Error(url)); img.src=url;
  });
}

function buildTopBottomProfiles(imageData, w, h){
  const d = imageData.data; const top = new Array(w).fill(h); const bottom = new Array(w).fill(-1);
  for(let x=0;x<w;x++){
    for(let y=0;y<h;y++){ if(d[(y*w + x)*4 + 3] >= PROFILE_ALPHA_MIN){ top[x]=y; break; } }
    for(let y=h-1;y>=0;y--){ if(d[(y*w + x)*4 + 3] >= PROFILE_ALPHA_MIN){ bottom[x]=y; break; } }
    if(bottom[x] < 0) bottom[x] = h-1; if(top[x] >= h) top[x] = 0;
  }
  return { top, bottom };
}

function trimAndCentroidAndProfiles(img){
  const c=document.createElement("canvas"); c.width=img.width; c.height=img.height;
  const g=c.getContext("2d"); g.drawImage(img,0,0);
  const im=g.getImageData(0,0,c.width,c.height); const d=im.data;
  let minX=c.width, minY=c.height, maxX=-1, maxY=-1, sumA=0, sumX=0, sumY=0;
  for(let y=0;y<c.height;y++){
    for(let x=0;x<c.width;x++){
      const a = d[(y*c.width + x)*4 + 3];
      if(a >= TRIM_ALPHA_MIN){ if(x<minX) minX=x; if(y<minY) minY=y; if(x>maxX) maxX=x; if(y>maxY) maxY=y; }
      if(a >= CENTROID_ALPHA_MIN){ sumA += a; sumX += x*a; sumY += y*a; }
    }
  }
  if(maxX<0 || maxY<0) return Promise.resolve({ img, w: img.width, h: img.height, cx: img.width/2, cy: img.height/2, top:null, bottom:null });
  const w = (maxX-minX+1); const h = (maxY-minY+1);
  const outC=document.createElement("canvas"); outC.width=w; outC.height=h;
  const og=outC.getContext("2d"); og.drawImage(c, minX, minY, w, h, 0, 0, w, h);
  const cropped = og.getImageData(0,0,w,h);
  const { top, bottom } = buildTopBottomProfiles(cropped, w, h);
  let cx=w/2, cy=h/2; if(sumA>0){ cx = (sumX/sumA) - minX; cy = (sumY/sumA) - minY; }
  const out=new Image(); out.src=outC.toDataURL("image/png");
  return new Promise((res,rej)=>{ out.onload=()=>res({ img: out, w, h, cx, cy, top, bottom }); out.onerror=rej; });
}

const state = {
  running:false, bg:null, blocks:[], towerScale:1, tower:[], current:null, particles:[], smokes:[], rings:[], flash:0,
  cameraShake:0, cameraX:0, cameraY:0, towerOffsetY:0, towerOffsetV:0, questionIndex:0, waitingAnswer:false, dropping:false,
  blockIndex:0, readyForNext:false, finished:false, score:0, scoreFloats:[]
};
function setNextEnabled(on){ state.readyForNext = on; nextBtn.disabled = !on; }
function groundY(){ return H - 70 + state.towerOffsetY; }
function alignedXForIdx(idx){ return (W/2) - (state.blocks[idx].cx * state.towerScale); }
function blockSize(idx){ const b = state.blocks[idx]; return { w: b.w*state.towerScale, h: b.h*state.towerScale }; }
function computeTowerScale(blocks){
  const maxW = Math.max(...blocks.map(b => b.w)); const totalH = blocks.reduce((s,b)=>s+b.h,0);
  return Math.min(DESIRED_TOWER_WIDTH() / maxW, Math.max(220, H - SAFE_TOP_MARGIN - SAFE_BOTTOM_MARGIN) / totalH);
}
function computeStackY(upper, lower){
  const su = state.towerScale; const upperMeta = state.blocks[upper.idx]; const lowerMeta = state.blocks[lower.idx];
  const upperBotArr = upperMeta.bottom; const lowerTopArr = lowerMeta.top;
  const overlapLeft = Math.max(upper.x, lower.x); const overlapRight = Math.min(upper.x + upper.w, lower.x + lower.w);
  if(overlapRight <= overlapLeft + 2){ return Math.round(lower.y - upper.h); }
  let yMaxAllowed = Infinity;
  for(let wx = overlapLeft; wx <= overlapRight; wx += 2){
    const xu = Math.floor((wx - upper.x) / su); const xl = Math.floor((wx - lower.x) / su);
    if(xu < 0 || xu >= upperMeta.w || xl < 0 || xl >= lowerMeta.w) continue;
    const allowed = lower.y + lowerTopArr[xl]*su - upperBotArr[xu]*su;
    if(allowed < yMaxAllowed) yMaxAllowed = allowed;
  }
  return Math.round(yMaxAllowed) - 1;
}

function spawnBlock(){
  if(state.finished) return;
  if(state.blockIndex >= QUESTIONS.length){ finishGame(); return; }
  const idx = state.blockIndex % state.blocks.length; const {w,h} = blockSize(idx);
  state.current = { idx, w, h, x: alignedXForIdx(idx), y: -h - 30 };
  state.dropping=false; state.waitingAnswer=false; setNextEnabled(false);
}

function settleCurrentBlock(){
  const b = state.current;
  let yTarget = (state.tower.length===0) ? Math.round(groundY() - b.h) : computeStackY(b, state.tower[state.tower.length - 1]);
  b.x = Math.round(b.x); b.y = Math.round(yTarget);
  state.tower.push({ x:b.x, y:b.y, w:b.w, h:b.h, idx:b.idx, squash:1.0, squashV:0.0 });
  state.score += SCORE_PER_BLOCK; scoreNum.textContent = String(state.score);
  state.current=null; state.cameraShake = Math.max(state.cameraShake, SHAKE_ON_LAND); state.towerOffsetV -= 120;
}

function boomAt(block){
  const cx = block.x + block.w/2; const cy = block.y + block.h/2;
  state.flash = Math.min(1, state.flash + 0.95);
  state.rings.push({ x:cx, y:cy, r:10, vr: 900, life:0.45, age:0 });
  for(let i=0;i<44;i++){
    const a=Math.random()*Math.PI*2; const sp=160+Math.random()*720;
    state.particles.push({ x:cx,y:cy, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp-(260+Math.random()*360), life:0.55+Math.random()*0.35, age:0, r:2+Math.random()*4 });
  }
  state.cameraShake = Math.max(state.cameraShake, SHAKE_ON_BOOM); playBoom();
}

function finishGame(){ state.finished = true; setNextEnabled(false); finishScoreEl.textContent = String(state.score); finishLayer.style.display="flex"; }
restartBtn.addEventListener("click", async ()=>{ finishLayer.style.display="none"; startLayer.style.display="flex"; });

function update(dt){
  if(!state.running) return;
  if(state.cameraShake>0){ state.cameraShake=Math.max(0, state.cameraShake - dt*22); const s=state.cameraShake; state.cameraX=(Math.random()*2-1)*s; state.cameraY=(Math.random()*2-1)*s; } else { state.cameraX=0; state.cameraY=0; }
  state.flash = Math.max(0, state.flash - dt*3.8);
  state.towerOffsetV += (-55*state.towerOffsetY - 10*state.towerOffsetV)*dt; state.towerOffsetY += state.towerOffsetV*dt; state.towerOffsetY = Math.max(-10, Math.min(10, state.towerOffsetY));
  for(const b of state.tower){ b.squashV += (-40*(b.squash-1)-8*b.squashV)*dt; b.squash += b.squashV*dt; b.squash = Math.max(0.88, Math.min(1.08, b.squash)); }
  for(const p of state.particles){ p.age+=dt; p.vy+=980*dt; p.x+=p.vx*dt; p.y+=p.vy*dt; } state.particles = state.particles.filter(p => p.age < p.life);
  for(const s of state.smokes){ s.age+=dt; s.vy+=120*dt; s.x+=s.vx*dt; s.y+=s.vy*dt; } state.smokes = state.smokes.filter(s => s.age < s.life);
  for(const r of state.rings){ r.age+=dt; r.r+=r.vr*dt; } state.rings = state.rings.filter(r => r.age < r.life);

  if(state.current){
    const b=state.current;
    if(!state.waitingAnswer){
      if(state.dropping){
        let yTarget = (state.tower.length===0) ? groundY() - b.h : computeStackY(b, state.tower[state.tower.length - 1]);
        b.y += DROP_SPEED*dt;
        if(b.y >= yTarget){ b.y = yTarget; settleCurrentBlock(); setNextEnabled(true); }
      } else {
        const stopY = Math.max(80, (state.tower.length===0 ? groundY() : state.tower[state.tower.length-1].y) - b.h - 18);
        b.y += FALL_SPEED*dt;
        if(b.y>=stopY){ b.y=stopY; state.waitingAnswer=true; showQuestion(); }
      }
    }
  }
  heightTxt.textContent = String(state.tower.length);
  const pct = Math.max(0, Math.min(100, Math.round((state.tower.length / QUESTIONS.length)*100)));
  pctTxt.textContent = pct + "%"; barFill.style.width = pct + "%";
}

function draw(){
  ctx.clearRect(0,0,W,H); ctx.save(); ctx.translate(state.cameraX, state.cameraY);
  if(state.bg){ const img=state.bg; const scale=Math.max(W/img.width,H/img.height); const dw=img.width*scale, dh=img.height*scale; ctx.drawImage(img,(W-dw)/2,(H-dh)/2,dw,dh); } 
  else { ctx.fillStyle="#0b0f18"; ctx.fillRect(0,0,W,H); }
  const grd=ctx.createRadialGradient(W*0.5,H*0.45,60, W*0.5,H*0.5, Math.max(W,H)*0.7); grd.addColorStop(0,"rgba(0,0,0,0)"); grd.addColorStop(1,"rgba(0,0,0,0.45)"); ctx.fillStyle=grd; ctx.fillRect(0,0,W,H);
  
  for(const b of state.tower){ 
    const img = state.blocks[b.idx].img; ctx.save();
    ctx.shadowColor = "rgba(0,0,0,.45)"; ctx.shadowBlur = 14;
    const cx = b.x + b.w/2; const cy = b.y + b.h; const sx = 1 + (1 - b.squash) * 0.35; const sy = b.squash;
    ctx.translate(cx, cy); ctx.scale(sx, sy); ctx.translate(-cx, -cy);
    ctx.drawImage(img, b.x, b.y, b.w, b.h); ctx.restore();
  }
  if(state.current){ 
    const b = state.current; const img = state.blocks[b.idx].img;
    ctx.save(); ctx.shadowColor = "rgba(120,190,255,.35)"; ctx.shadowBlur = 18; ctx.drawImage(img, b.x, b.y, b.w, b.h); ctx.restore();
  }
  for(const s of state.smokes){ const t = s.age / s.life; const a = (1 - t) * 0.35; const r = s.rad * (1 + t*1.25); ctx.fillStyle = `rgba(20,20,20,${a})`; ctx.beginPath(); ctx.arc(s.x, s.y, r, 0, Math.PI*2); ctx.fill(); }
  for(const r of state.rings){ const t = r.age / r.life; const a = (1 - t) * 0.55; ctx.strokeStyle = `rgba(255,255,255,${a})`; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(r.x, r.y, r.r, 0, Math.PI*2); ctx.stroke(); }
  for(const p of state.particles){ const a = 1 - (p.age/p.life); ctx.fillStyle = `rgba(255, 200, 120, ${0.78*a})`; ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill(); }
  if(state.flash>0){ ctx.fillStyle = `rgba(255,255,255,${state.flash*0.22})`; ctx.fillRect(0,0,W,H); }
  ctx.restore(); requestAnimationFrame(draw);
}
let lastT=0; function loop(t){ if(!lastT) lastT=t; const dt=Math.min(0.033,(t-lastT)/1000); lastT=t; update(dt); requestAnimationFrame(loop); }

// ТАЙМЕР И ВОПРОСЫ
let timerInterval = null;
function normalizeAnswer(s){ return String(s??"").trim().toLowerCase(); }

function showQuestion(){
  const qi = state.questionIndex; 
  // Безопасно берем вопрос
  const q = QUESTIONS[qi % QUESTIONS.length];

  overlay.style.display="flex"; msgEl.textContent=""; answersEl.innerHTML=""; answersEl.style.display="flex";
  qEl.textContent=q.q; badgeEl.textContent=`${qi+1} / ${QUESTIONS.length}`;
  
  // Создаем кнопки
  for(const opt of q.options){
      const btn=document.createElement("button"); btn.className="btn"; btn.textContent=opt;
      btn.addEventListener("click", ()=>checkAnswer(opt)); answersEl.appendChild(btn);
  }

  // ЗАПУСК ТАЙМЕРА
  if(TIMER_ENABLED) {
      timerWrap.style.display = 'block'; let timeLeft = TIMER_SEC; timerBar.style.width = '100%';
      if(timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(() => {
          timeLeft--; timerBar.style.width = (timeLeft / TIMER_SEC * 100) + "%";
          if(timeLeft <= 0) { clearInterval(timerInterval); checkAnswer(null); }
      }, 1000);
  }
}

function hideQuestion(){ overlay.style.display="none"; timerWrap.style.display='none'; if(timerInterval) clearInterval(timerInterval); }

function checkAnswer(userValue){
  if(timerInterval) clearInterval(timerInterval);
  const qi = state.questionIndex; const q = QUESTIONS[qi % QUESTIONS.length];
  
  // null = время вышло
  const ok = userValue !== null && (normalizeAnswer(userValue) === normalizeAnswer(q.answer));
  const waitingBlock = state.current;
  
  if(ok){
    msgEl.innerHTML = `<span style="color: var(--good); font-weight:900;">Верно!</span> Блок опускается.`;
    playGood(); state.dropping = false;
    setTimeout(()=>{ hideQuestion(); state.waitingAnswer = false; if(state.current) state.dropping = true; else setNextEnabled(true); }, 220);
  } else {
    msgEl.innerHTML = `<span style="color: var(--bad); font-weight:900;">${userValue===null?"Время вышло!":"Неверно!"}</span> Блок взрывается.`;
    state.dropping = false;
    setTimeout(()=>{
      hideQuestion(); state.waitingAnswer = false;
      if(waitingBlock && waitingBlock === state.current) boomAt(waitingBlock);
      state.current = null; setNextEnabled(true);
    }, 1000);
  }
  state.blockIndex++;
}

nextBtn.addEventListener("click", ()=>{ if(nextBtn.disabled) return; state.questionIndex++; spawnBlock(); });

async function startGame(){
  errBox.style.display="none"; errList.innerHTML=""; ensureAudio();
  if(audioCtx.state==="suspended"){ try{ await audioCtx.resume(); }catch{} }
  Object.assign(state, { running:false, bg:null, blocks:[], towerScale:1, tower:[], current:null, particles:[], smokes:[], rings:[], flash:0, cameraShake:0, cameraX:0, cameraY:0, towerOffsetY:0, towerOffsetV:0, questionIndex:0, waitingAnswer:false, dropping:false, blockIndex:0, readyForNext:false, finished:false, score:0 });
  scoreNum.textContent = "0"; setNextEnabled(false);
  
  const missing=[];
  try{ state.bg = await loadImage(assetUrl(BG_FILE)); } catch{ missing.push(BG_FILE); }
  const blocks=[];
  for(const f of BLOCK_FILES){
    try{
      const raw = await loadImage(assetUrl(f)); const t = await trimAndCentroidAndProfiles(raw);
      blocks.push({ file:f, img:t.img, w:t.w, h:t.h, cx:t.cx, cy:t.cy, top:t.top, bottom:t.bottom });
    } catch { missing.push(f); }
  }
  if(missing.length){ errBox.style.display="block"; for(const f of missing){ const li=document.createElement("li"); li.textContent = f; errList.appendChild(li); } return; }
  state.towerScale = computeTowerScale(blocks); state.blocks = blocks;
  state.running = true; spawnBlock();
}
playBtn.addEventListener("click", async ()=>{ startLayer.style.display="none"; await startGame(); });
requestAnimationFrame(loop); requestAnimationFrame(draw);
</script>
</body>
</html>
