<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Башня знаний</title>
  <style>
    :root{ --hud-bg: rgba(10, 12, 18, .55); --panel-bg: rgba(20, 22, 30, .95); --text: #fff; --gold: #FFD700; --good: #00C851; --bad: #ff4444; }
    html,body{height:100%;margin:0;font-family:system-ui,sans-serif;background:#000;color:white;overflow:hidden;}
    canvas{width:100%;height:100%;display:block; image-rendering: pixelated;}

    #timerWrap { position: absolute; top:0; left:0; width:100%; height:8px; display:none; z-index:20; background:rgba(255,255,255,0.1); }
    #timerBar { height:100%; width:100%; background: linear-gradient(90deg, #ff9a9e, #ff5252); transition: width 0.1s linear; }

    #hud { position:absolute; top:15px; left:15px; right:15px; display:flex; justify-content:space-between; z-index:3; pointer-events:none; }
    .pill { background:var(--hud-bg); border:1px solid rgba(255,255,255,0.2); border-radius:20px; padding:8px 15px; font-weight:bold; backdrop-filter:blur(5px); }

    #overlay { position:absolute; inset:0; background:rgba(0,0,0,0.85); display:none; align-items:center; justify-content:center; z-index:10; flex-direction:column; }
    #card { width:90%; max-width:500px; background:var(--panel-bg); border:2px solid var(--gold); border-radius:15px; padding:25px; text-align:center; box-shadow:0 0 40px rgba(255,215,0,0.2); max-height:90vh; overflow-y:auto; }
    
    #qImg { max-width:100%; max-height:200px; border-radius:8px; margin-bottom:15px; display:none; border:1px solid #555; margin: 0 auto 15px; }
    #qAudio { width:100%; margin-bottom:15px; display:none; }
    #qText { font-size:22px; color:var(--gold); font-weight:bold; margin-bottom:20px; line-height:1.3; }
    
    .ans-grid { display:grid; gap:10px; grid-template-columns:1fr; }
    .ans-grid.cols { grid-template-columns:1fr 1fr; }
    .btn { background:rgba(255,255,255,0.1); border:1px solid var(--gold); color:white; padding:12px; border-radius:8px; cursor:pointer; font-size:16px; transition:0.2s; }
    .btn:hover { background:var(--gold); color:black; }
    
    #inputBox { display:none; }
    input[type=text] { width:70%; padding:10px; background:#222; border:1px solid #555; color:white; font-size:16px; border-radius:5px; }
    #msg { margin-top:15px; font-weight:bold; min-height:20px; }
    
    #startScreen, #endScreen { position:absolute; inset:0; background:rgba(0,0,0,0.95); z-index:20; display:flex; flex-direction:column; align-items:center; justify-content:center; text-align:center; }
    h1 { color:var(--gold); font-size:40px; margin-bottom:10px; text-shadow:0 0 15px var(--gold); }
    .big-btn { background:var(--gold); color:black; border:none; padding:15px 40px; font-size:20px; border-radius:30px; font-weight:bold; cursor:pointer; margin-top:20px; box-shadow:0 0 20px var(--gold); transition:0.3s; }
    .big-btn:hover { transform:scale(1.05); }
    .hidden { display:none !important; }
  </style>
</head>
<body>

<div id="wrap">
  <canvas id="c"></canvas>
  <div id="timerWrap"><div id="timerBar"></div></div>
  <div id="hud">
    <div class="pill">Блоков: <span id="floorVal">0</span></div>
    <div class="pill">Счёт: <span id="scoreVal">0</span></div>
  </div>

  <div id="overlay">
    <div id="card">
      <img id="qImg">
      <audio id="qAudio" controls></audio>
      <div id="qText"></div>
      <div id="ansBox" class="ans-grid"></div>
      <div id="inputBox">
        <input type="text" id="ansInput" placeholder="Ответ...">
        <button class="btn" onclick="checkInput()">OK</button>
      </div>
      <div id="msg"></div>
    </div>
  </div>

  <div id="startScreen">
    <h1>БАШНЯ ЗНАНИЙ</h1>
    <p style="color:#ccc; max-width:400px;">Построй башню из 9 блоков.<br>Верный ответ - блок ставится.<br>Ошибка - блок взрывается.</p>
    <button class="big-btn" onclick="startGame()">НАЧАТЬ</button>
  </div>

  <div id="endScreen" class="hidden">
    <h1 id="endTitle">ФИНАЛ</h1>
    <p>Счёт: <b id="finalScore" style="color:var(--gold); font-size:24px;">0</b></p>
    <button class="big-btn" onclick="location.reload()">ЗАНОВО</button>
  </div>
  
  <audio id="bgMusic" loop></audio>
</div>

<script>
const REPO = "https://svetlana18011991.github.io/redactor_bashnya/";
const BLOCK_IMGS = ["3.png","4.png","5.png","6.png","7.png","8.png","9.png","10.png","11.png"];
let QS = [{type:"choice",q:"Пример вопроса?",options:["1","2"],answer:"1"}];
let BG_SRC = REPO + "1.png";
let SHUFFLE = false;
let MUSIC_SRC = null;
const OVERLAP = 4; // Легкий нахлест для устранения щелей

if(window.GAME_DATA) {
    if(window.GAME_DATA.qs && window.GAME_DATA.qs.length) QS = window.GAME_DATA.qs;
    if(window.GAME_DATA.bg) BG_SRC = window.GAME_DATA.bg;
    if(window.GAME_DATA.music) MUSIC_SRC = window.GAME_DATA.music;
    SHUFFLE = window.GAME_DATA.shuffle;
} else {
    try {
        const p = new URLSearchParams(location.search).get('data');
        if(p) {
            const d = JSON.parse(decodeURIComponent(escape(atob(p))));
            if(d.qs) QS = d.qs;
            if(d.bg) BG_SRC = d.bg;
        }
    } catch(e){}
}

const cvs = document.getElementById("c"), ctx = cvs.getContext("2d");
let W, H;
const resize = ()=>{ W=cvs.width=window.innerWidth; H=cvs.height=window.innerHeight; };
window.addEventListener("resize", resize); resize();

const ASSETS = { blocks: [], bg: null };
const load = (src) => new Promise(r => { const i=new Image(); i.onload=()=>r(i); i.onerror=()=>r(null); i.src=(src.includes('data:')||src.includes('http'))?src:REPO+src; });

async function init() {
    ASSETS.bg = await load(BG_SRC);
    for(let f of BLOCK_IMGS) ASSETS.blocks.push(await load(f));
    
    if(SHUFFLE) {
        for (let i = QS.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [QS[i], QS[j]] = [QS[j], QS[i]];
        }
    }
}
init();

const game = { run: false, tower: [], curr: null, score: 0, qIdx: 0, camY: 0, particles: [], rings: [], smokes: [], wait: false, blockIdx: 0, offY:0 };

function startGame() {
    document.getElementById('startScreen').classList.add('hidden');
    if(MUSIC_SRC) {
        const audio = document.getElementById('bgMusic');
        audio.src = MUSIC_SRC; audio.volume = 0.3;
        audio.play().catch(e=>{});
    }
    game.run = true; game.tower = []; game.score = 0; game.qIdx = 0; game.camY = 0; game.blockIdx = 0; game.offY = 0;
    updHUD(); spawn(); loop();
}

function spawn() {
    if(game.blockIdx >= 9) { end(true); return; }
    const img = ASSETS.blocks[game.blockIdx % ASSETS.blocks.length];
    const towerH = 9 * (img.height - OVERLAP); 
    const scale = Math.min(360 / img.width, (H - 200) / towerH);
    
    game.curr = {
        img: img, w: img.width * scale, h: img.height * scale,
        x: W/2 - (img.width * scale)/2, y: -200, 
        drop: false
    };
    game.wait = false;
}

function updHUD() {
    document.getElementById('floorVal').innerText = game.tower.length;
    document.getElementById('scoreVal').innerText = game.score;
}

function update(dt) {
    if(!game.run) return;
    game.offY = game.offY * 0.9 + game.camY * 0.1;

    // EFFECTS UPDATE
    game.particles.forEach((p,i)=>{
        p.x+=p.vx; p.y+=p.vy; p.l-=0.02;
        if(p.l<=0) game.particles.splice(i,1);
    });
    game.smokes.forEach((s,i)=>{
        s.y-=1; s.x+=s.vx; s.l-=0.01; s.rad+=0.2;
        if(s.l<=0) game.smokes.splice(i,1);
    });
    game.rings.forEach((r,i)=>{
        r.rad+=5; r.l-=0.03;
        if(r.l<=0) game.rings.splice(i,1);
    });

    if(game.curr) {
        const b = game.curr;
        if(game.wait) return;

        if(b.drop) {
            let landY = H - 50;
            if(game.tower.length) landY = game.tower[game.tower.length-1].y - b.h + OVERLAP;
            
            b.y += 900 * dt;
            if(b.y >= landY) {
                b.y = landY;
                game.tower.push(b);
                game.curr = null;
                game.blockIdx++;
                game.score += 100;
                updHUD();
                if(game.tower.length > 2) game.camY += b.h - OVERLAP;
                setTimeout(spawn, 300);
            }
        } else {
            let hoverY = H - 200;
            if(game.tower.length) hoverY = game.tower[game.tower.length-1].y - 150;
            
            b.y += 600 * dt;
            if(b.y >= hoverY) {
                b.y = hoverY;
                ask();
            }
        }
    }
}

function ask() {
    game.wait = true;
    const q = QS[game.qIdx % QS.length];
    const qText = document.getElementById('qText');
    const img = document.getElementById('qImg');
    const aud = document.getElementById('qAudio');
    const ansBox = document.getElementById('ansBox');
    const inpBox = document.getElementById('inputBox');
    
    document.getElementById('msg').innerText = "";
    qText.innerText = q.q;
    
    img.style.display = q.img ? 'block' : 'none';
    if(q.img) img.src = q.img;
    
    aud.style.display = q.audio ? 'block' : 'none';
    if(q.audio) aud.src = q.audio; else aud.pause();

    ansBox.innerHTML = '';
    if(q.type === 'choice') {
        ansBox.style.display = 'grid'; inpBox.style.display = 'none';
        ansBox.className = q.options.length > 4 ? 'ans-grid cols' : 'ans-grid';
        q.options.forEach(opt => {
            const btn = document.createElement('button');
            btn.className = 'btn'; btn.innerText = opt;
            btn.onclick = () => answer(opt === q.answer);
            ansBox.appendChild(btn);
        });
    } else {
        ansBox.style.display = 'none'; inpBox.style.display = 'block';
        const inp = document.getElementById('ansInput');
        inp.value = ''; inp.dataset.ans = q.answer; inp.focus();
    }

    document.getElementById('overlay').style.display = 'flex';
    if(q.timer) startTimer(q.timer); else document.getElementById('timerWrap').style.display = 'none';
}

function startTimer(s) {
    const bar = document.getElementById('timerBar');
    const wrap = document.getElementById('timerWrap');
    wrap.style.display = 'block'; bar.style.width = '100%';
    let left = s;
    if(timerInt) clearInterval(timerInt);
    timerInt = setInterval(() => {
        left -= 0.1;
        bar.style.width = (left/s*100) + "%";
        if(left <= 0) { clearInterval(timerInt); answer(false); }
    }, 100);
}

function checkInput() {
    const inp = document.getElementById('ansInput');
    answer(inp.value.trim().toLowerCase() === inp.dataset.ans.trim().toLowerCase());
}

function answer(win) {
    if(timerInt) clearInterval(timerInt);
    document.getElementById('timerWrap').style.display = 'none';
    const msg = document.getElementById('msg');
    
    if(win) {
        msg.innerText = "ВЕРНО!"; msg.style.color = "var(--good)";
        setTimeout(() => { 
            document.getElementById('overlay').style.display = 'none';
            game.wait = false;
            game.curr.drop = true;
        }, 1000);
    } else {
        msg.innerText = "НЕВЕРНО! Блок сгорает."; msg.style.color = "var(--bad)";
        setTimeout(() => { 
            document.getElementById('overlay').style.display = 'none';
            boom();
        }, 1500);
    }
    game.qIdx++;
}

// ОРИГИНАЛЬНЫЙ ВЗРЫВ
function boom() {
    const b = game.curr;
    const cx = b.x + b.w/2;
    const cy = b.y + b.h/2;
    
    // Вспышка и кольцо
    game.rings.push({x:cx, y:cy, rad:10, l:1});
    
    // Дым
    for(let i=0; i<10; i++) {
        game.smokes.push({
            x: cx, y: cy,
            vx: (Math.random()-0.5)*5, vy: (Math.random()-0.5)*5,
            l: 1, rad: 10
        });
    }
    
    // Частицы
    for(let i=0; i<30; i++) {
        game.particles.push({
            x: cx, y: cy,
            vx: (Math.random()-0.5)*15, vy: (Math.random()-0.5)*15 - 5,
            l: 1
        });
    }
    
    game.curr = null;
    game.wait = false;
    game.blockIdx++; 
    setTimeout(spawn, 500);
}

function end(win) {
    game.run = false;
    document.getElementById('endScreen').classList.remove('hidden');
    document.getElementById('endTitle').innerText = win ? "БАШНЯ ГОТОВА!" : "ФИНАЛ";
    document.getElementById('finalScore').innerText = game.score;
}

function loop() {
    if(!game.run) return;
    requestAnimationFrame(loop);
    update(0.016);
    
    ctx.clearRect(0,0,W,H);
    if(ASSETS.bg) {
        const s = Math.max(W/ASSETS.bg.width, H/ASSETS.bg.height);
        ctx.drawImage(ASSETS.bg, (W-ASSETS.bg.width*s)/2, (H-ASSETS.bg.height*s)/2, ASSETS.bg.width*s, ASSETS.bg.height*s);
    } else { ctx.fillStyle="#111"; ctx.fillRect(0,0,W,H); }

    ctx.save();
    ctx.translate(0, Math.round(game.offY));

    game.tower.forEach(b => ctx.drawImage(b.img, Math.round(b.x), Math.round(b.y), b.w, b.h));
    if(game.curr) ctx.drawImage(game.curr.img, Math.round(game.curr.x), Math.round(game.curr.y), game.curr.w, game.curr.h);

    // Render Effects
    game.smokes.forEach(s => {
        ctx.fillStyle = `rgba(50,50,50,${s.l*0.5})`;
        ctx.beginPath(); ctx.arc(s.x, s.y, s.rad, 0, Math.PI*2); ctx.fill();
    });
    game.rings.forEach(r => {
        ctx.strokeStyle = `rgba(255,255,255,${r.l})`;
        ctx.lineWidth = 4;
        ctx.beginPath(); ctx.arc(r.x, r.y, r.rad, 0, Math.PI*2); ctx.stroke();
    });
    game.particles.forEach(p => {
        ctx.fillStyle = `rgba(255,${Math.random()*150+100},50,${p.l})`;
        ctx.fillRect(p.x,p.y,5,5);
    });

    ctx.restore();
    ctx.fillStyle="#222"; ctx.fillRect(0, H-50+Math.round(game.offY), W, 50);
}
</script>
</body>
</html>
